<!DOCTYPE html>
<html>
<head lang="en">
    <link type="text/css" href="../css/style.css" rel="stylesheet"/>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <article>
        <h3>一。语法</h3>
        <p>ECMAScript中的一切都区分大小写</p>
        <p> 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</p>
        <p> 其他字符可以是字母、下划线、美元符号或数字&nbsp;<strong>但是开发中，推荐只使用字母开头</strong></p>
        <p>标识符的推荐格式：    userName; classId</p>
        <p>注释,由于使用/*  */ 注释特殊情况会引发不必要的问题,所以都采用//注释</p>
        <p>语句结尾都要加上；<strong>推荐</strong></p>
        <p>使用代码块，让代码更有条理，尤其是在控制语句中{&nbsp;}<strong>推荐</strong></p>

            <h4>严格模式</h4>
            ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为JavaScript 定义了一种不同的
            解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全
            的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：
            "use strict";
            这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），
            用于告诉支持的JavaScript 引擎切换到严格模式。这是为不破坏ECMAScript 3 语法而特意选定的语法。
            在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：
            function doSomething(){
            "use strict";
            //函数体
            }
            严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支
            持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。
        <h4>ECMA-262关键字</h4>
        <table>
            <tr>
                <td>break</td><td>do</td><td>instanceof</td><td>typeof</td>
            </tr>
            <tr>
                <td>case</td><td>else</td><td>new</td><td>var</td>
            </tr>
            <tr>
                <td>catch</td><td>finally</td><td>return</td><td>void</td>
            </tr>
            <tr>
                <td>continue</td><td>for</td><td>switch</td><td>while</td>
            </tr>
            <tr>
                <td>debugger</td><td>function</td><td>this</td><td>with</td>
            </tr>
            <tr>
                <td>default</td><td>if</td><td>throw</td>
            </tr>
            <tr>
                <td>delete</td><td>in</td><td>try</td>
            </tr>
        </table>

        <h4>ECMA-262保留字</h4>
        略。
        <h4>变量</h4>
            <p>ECMAScript中的变量是松散类型的。定义变量使用var操作符。</p>
            <p>var msg;  //未初始化的变量会保存一个特殊值，undefined</p>
        <h4>数据类型</h4>
            <p>ECMAScript中共有5种基本数据类型：Undefined、Null、Boolean、Number
                和String。1种复杂数据类型：Object。ECMAScript不支持任何自定义类型</p>
        <h4>typeof操作符</h4>
        <p>  "undefined"——如果这个值未定义；</p>
        <p>  "boolean"——如果这个值是布尔值；</p>
        <p>  "string"——如果这个值是字符串；</p>
        <p>  "number"——如果这个值是数值；</p>
        <p>  "object"——如果这个值是对象或null；</p>
        <p>  "function"——如果这个值是函数。</p>
        <p>对未初始化和未声明的变量执行typeof 操作符都返回了undefined 值.</p>
        <p>从逻辑上讲，null值表示一个空对象指针，因此typeof检测null时会返回object。</p>
        <p>下列值都为假</p>
        <p>undefined</p>
        <p>null</p>
        <p>数字0和NaN</p>
        <p>空串''</p>
        <h4>Number</h4>
        <p>Number使用<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE754标准</a>来表示整数和浮点数</p>
        <p>不要测试浮点数的数值，比如比较计算结果 0.1+0.2==0.3，这样得不到预期的数值</p>
        <h4>数值范围</h4>
        <p>Number.MIN_VALUE :5e-324(对于大多数浏览器)</p>
        <p>Number.MAX_VALUE :1.7976931348623157e+308(对于大多数浏览器)</p>
        <p>Infinity(正无穷) Number.NEGATIVE_INFINITY</p>
        <p>-Infinity（负无穷）Number.POSITIVE_INFINITY</p>
        <p>isFinite(). 判断是否有穷。对于正无穷与负无穷之间的数值返回true。</p>
        <p>NaN与任何数值都不相等，包括自身。</p>
        <h4>数值转换</h4>
        <p>  Number().转换规则：</p>
         <p>如果是Boolean 值，true 和false 将分别被转换为1 和0。</p>
        <p>如果是数字值，只是简单的传入和返回。</p>
        <p>如果是null 值，返回0。</p>
        <p>如果是undefined，返回NaN。</p>
        <p>如果是字符串，遵循下列规则：</p>
        <p>1 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"
        会变成1，"123"会变成123，而"011"会变成11（注意：前导的零被忽略了）；</p>
        <p>2 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽
        略前导零）；</p>
        <p>3 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整
        数值；</p>
        <p>4 如果字符串是空的（不包含任何字符），则将其转换为0；</p>
        <p>5 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
         如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换
        的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符
        串值。</p>
        <p>  parseInt()</p>
        <p>  parseFloat()</p>
        <h4>字符串转换</h4>
        <p>toString().（非null , undefined）</p>
        <p>String(). 任何情况</p>
        <p> 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；</p>
        <p> 如果值是null，则返回"null"；</p>
        <p> 如果值是undefined，则返回"undefined"。</p>
        <h4>Object类型</h4>
        <p>var o = new Object();//对象的创建。可以省略括号但不推荐</p>
        <h4>Object实例的属性和方法</h4>
        <p> constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）
        就是Object()。</p>
        <p> hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例
        的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例
        如：o.hasOwnProperty("name")）。</p>
        <p> isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5 章将讨论原
        型）。</p>
        <p> propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句
        （本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符
        串形式指定。</p>
        <p> toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
        <p> toString()：返回对象的字符串表示。</p>
        <p> valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值
        相同。</p>
        <h4>操作符</h4>
        <p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种
        情况通常被称作副效应。）请看下面这个例子。</p>
        <p>var age = 29;</p>
        <p>var anotherAge = --age + 2;</p>
        <p>alert(age); // 输出28</p>
        <p> alert(anotherAge); // 输出30</p>
        <p> 这个例子中变量anotherAge 的初始值等于变量age 的值前置递减之后加2。由于先执行了减法操
        作，age 的值变成了28，所以再加上2 的结果就是30。
        由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子：</p>
        <p>var num1 = 2;</p>
        <p>var num2 = 20;</p>
        <p>var num3 = --num1 + num2; // 等于21</p>
        <p>var num4 = num1 + num2; // 等于21</p>
        <p>后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求
            值之后才执行的。</p>
        <p>var num1 = 2;</p>
        <p>var num2 = 20;</p>
        <p>var num3 = num1-- + num2; // 等于22</p>
        <p>var num4 = num1 + num2; // 等于21</p>
        <p>一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。</p>
        <h4>位操作符</h4>
        <p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数
            值都以IEEE-754 64 位格式存储，但位操作符并不直接操作64 位的值。而是先将64 位的值转换成32 位
            的整数，然后执行操作，最后再将结果转换回64 位。对于开发人员来说，由于64 位存储格式是透明的，
            因此整个过程就像是只存在32 位的整数一样。
            对于有符号的整数，32 位中的前31 位用于表示整数的值。第32 位用于表示数值的符号：0 表示正
            数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以
            纯二进制格式存储，31 位中的每一位都表示2 的幂。第一位（叫做位0）表示20，第二位表示21，以此
            类推。没有用到的位以0 填充， 即忽略不计。例如， 数值18 的二进制表示是00000000000000000000000000010010，
            或者更简洁的10010。这是5 个有效位，这5位本身就决定了实际的值</p>
        <table>
            <tr>
                <td>1</td><td>0</td><td>0</td><td>1</td><td>0</td>
            </tr>
            <tr>
                <td colspan="5">(2^4*1)+(2^3*0)+(2^2*0)+(2^1*1)+(2^0*0)</td>
            </tr>
            <tr>
                <td>16+0+0+2+0</td>
            </tr>
        </table>
        <p>负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下
        列3 个步骤：

        <p>(1) 求这个数值绝对值的二进制码（例如，要求18 的二进制补码，先求18 的二进制码）；</p>
        <p>(2) 求二进制反码，即将0 替换为1，将1 替换为0；</p>
        <p>(3) 得到的二进制反码加1。</p>
        <p>要根据这3 个步骤求得-18 的二进制码，首先就要求得18 的二进制码，即：</p>
        <p>0000 0000 0000 0000 0000 0000 0001 0010</p>
        <p>然后，求其二进制反码，即0 和1 互换：</p>
        <p>1111 1111 1111 1111 1111 1111 1110 1101</p>
        <p>最后，二进制反码加1：</p>
        <p>1111 1111 1111 1111 1111 1111 1110 1101</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</p>
        <p>---------------------------------------</p>
        <p> 1111 1111 1111 1111 1111 1111 1110 1110</p>
        <p>这样，就求得了-18 的二进制表示，即11111111111111111111111111101110。要注意的是，在处理有
        符号整数时，是不能访问位31 的。
        ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，
        我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：</p>
        <p>var num = -18;</p>
        <p> alert(num.toString(2)); // "-10010"</p>
        <p>要把数值-18 转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补
        码并将其以更合乎逻辑的形式展示了出来。
        默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无
        符号整数。对于无符号整数来说，第32 位不再表示符号，因为无符号整数只能是正
        数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示
        数值。</p>
        <p>在ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成32
        位数值，然后执行位操作，最后再将32 位的结果转换回64 位数值。这样，表面上看起来就好像是在操
        作32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重
        的副效应，即在对特殊的NaN 和Infinity 值应用位操作时，这两个值都会被当成0 来处理。
        如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后
        再应用位操作。得到的结果将是一个数值。</p>
        <h4>ECMAScript参数</h4>
        <p>ECMAScript内部的参数用一个数组表示，函数体内可以用arguments对象来访问参数数组，
            从而获取传递给参数的。ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。
            ECMAScript没有重载，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</p>
        <p> ECMAScript 中的基本数据类型包括Undefined、Null、Boolean、Number 和String。</p>
        <p>    与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可
            用于表示所有数值。</p>
        <p>    ECMAScript 中也有一种复杂的数据类型，即Object 类型，该类型是这门语言中所有对象的基
            础类型。</p>
        <p>    严格模式为这门语言中容易出错的地方施加了限制。</p>
        <p>    ECMAScript 提供了很多与C 及其他类C 语言中相同的基本操作符，包括算术操作符、布尔操作
            符、关系操作符、相等操作符及赋值操作符等。</p>
        <p>    ECMAScript 从其他语言中借鉴了很多流控制语句，例如if 语句、for 语句和switch 语句等。
            ECMAScript 中的函数与其他语言中的函数有诸多不同之处。</p>
        <p>     无须指定函数的返回值，因为任何ECMAScript 函数都可以在任何时候返回任何值。</p>
        <p>    实际上，未指定返回值的函数返回的是一个特殊的undefined 值。</p>
        <p>    ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式
            传递的。</p>
        <p>     可以向ECMAScript 函数传递任意数量的参数，并且可以通过arguments 对象来访问这些参数。</p>
        <p>    由于不存在函数签名的特性，ECMAScript 函数不能重载。</p>
    </article>
</body>
</html>